# 黑马程序员Java零基础视频教程_上部(Java入门)

---

# Day01-java-introduction java入门


## 一.人机交互

---

## 二.java概况

---



## Day02-introduction java基础概念

## 1. 注释
1. 什么是注释？
注释是在程序指定位置添加的说明性的信息
简单理解 就是对代码的一种解释
2. 注释的分类？

       1. 单行注释 //注释信息
       2. 多行注释 /*注释信息*/
       3. 文档注释 /**注释信息*/
3. 注释的细节？
注释内容不会参与编译和运行，仅仅是对代码的解释说明
不管是单行注释还是多行注释，在书写的时候不要嵌套


---


## 2. 关键字
1.什么是关键字？
关键字：被java赋予了特定涵义的英文单词
2. 关键字的特点？
关键字的字母全部小写
常用的代码编辑器，对关键字有特殊颜色标记
3. class关键字是什么意思？
class：用于(创建/定义)一个类，后面跟随类名。类是java最基本的组成单元。

---

## 3. 字变量
1. 什么是字变量？
告诉程序员：数据在程序中的书写格式
2. java字变量的分类？

       字变量类型    说明                             举例
       整数类型      不带小数点的数字                  33 -5
       小数类型      带小数点的数字                    33.8 5.22
       字符串类型    用双引号括起来的内容    "          Hello World" "22"
       字符类型      用单引号括起来的内容 内容只能有一个 '1' 'w' '我'
       布尔类型      布尔值表示真假                     只有两个值 ture false
       空类型        一个特殊值 空值                    值 null
   
3. 一些特殊的制表符书写？
\t 制表符 在打印的时候，把前面字符串的长度补齐到8 或者是8的正数倍，最少一个空格，最多8个空格。
\r
\n 
---

## 4. 变量 
1. 变量的使用场景
当莫个数据经常发生改变的时候，我们也会有用变量来存储，当数据发生变化时，自要修改变量里面记录的值即可
2. 变量的打印格式？

       数据类型 变量名 = 数据值；
3. 变量的使用方法？
输出打印
参与计算
修改记录的值
4. 变量的注意事项
只能存一个值
变量名不允许重复定义
一条语句可以定义多个变量
变量使用之前一定要进行赋值


---



## Day03-operator 运算符

运算符 对字变量或者变量进行操作的符号
表达式 用运算符把自变量或者变量连接起来，符合java语法的式子可以称表达式
不同运算符连接的表达式体现的是不同类型的表达式

## 一.算术运算符

1. + 加
2. + 减
3. + 乘
4. / 除
5. % 取模 取余

+ 的三种情况:

1. 数字相加

       什么是隐式转换？
       (1)隐式转换 (自动类型提升)
       取值范围小的数值转成取值范围大的数值
       取值范围：
       取值范围:
       byte < short < int < long < float < double
       提升规则:
       1. 取值范围小的，和取值范围大的进行运算，小的会提升大的，在进行运算
       2. byte short char 三种类型的数据在运算的时候，都会直接提升为int，然后在进行计算



       (2)强制转换
        取值范围大的数字转成取值范围小的数值
        如果把一个取值范围大的数值，赋值给取值范围小的变量，
        是不允许直接赋值的，如果一定要这么做就需要加入强制转换
        格式:
        目标数据类型 变量名 = (目标数据类型)被强转数据；

2. 字符串相加

       当 "+"操作中出现字符串时，这个 "+"是字符串的连接符，而不是运算符了。
       会将前后的数据进行拼接，并产生新的字符串

3. 字符相加

       当字符 + 字符 或是字符 + 数字时，会把字符通过ASCLL码表查询的对应的数字再进行计算 

注意事项：
/和 % 的区别：两个数据做除法，取结果的商，% 取结果的余数
整数操作只能得到整数，要想得到小数，必须要有浮点数参与运算

---

## 二.自增自减运算符

1. 自增运算符
++ 加 变量值加 1

2. 自减运算符
-- 减 变量值减 1

注意事项:
++和--既可以放在变量的前面，也可以放在变量的后面
只要单独写一行结果是一样的
a ++ 先用后加
++a 先加后用

---

## 三.赋值运算符

1. = 赋值 int a = 10   将10赋值给变量a
2. += 加后赋值 a += b   将a + b
的值给a
3. -= 减后赋值 a -= b   将a - b
的值给a
4. *= 乘后赋值 a*= b   将a * b
的值给a
5. /= 除后赋值 a /= b   将a / b
的值给a
6. %= 取余后赋值 a %= b   将a % b
的值给a

---

## 四.关系运算符

1. == a==b 判断a和b的值是否相等，成立为true 不成立为false
2. != a!=b 判断a和b的值是否不相等，成立为true 不成立为false
3. (>) a>b 判断a是否大于b，成立为true 不成立为false
4. (>=) a>=b 判断a是否大于等于b，成立为true 不成立为false
5. (<) a(<)b 判断a是否小于b，成立为true 不成立为false
6. (<=) a(<=)b 判断a是否小于等于b，成立为true 不成立为false

注意事项：
关系运算符的结果都是boolean类型的，要么是ture，要么是false
千万不要把 == 写成 =

---

## 五.逻辑运算符

1. & 逻辑与(且) 并且 两边都为真 结果才是真
2. | 逻辑或     或者 两边都为假 结果才为假
3. ^ 逻辑异或   相同为false 不同为ture
4. ! 逻辑非     取反

 短路逻辑运算符

 1. && 短路与 结果&相同 但是有短路效果
 2. || 短路或 结果|相同 但是有短路效果

注意事项:

1. &| 无论左边ture false 右边都要执行
2. && || 如果左边你确定整个表达式的结果 右边不执行
3. && 左边为false 右边不管是真是假 整个表达式的结果一定是false
4. || 左边为true 右边不管是真是假 整个表达式的结果一定是true

---

## 六.三元运算符

三元运算符/三元表达式格式

       关系表达式 ? 表达式1 ：表达式2;

计算规则：

1. 首先计算关系表达式的值
2. 如果是ture 表达式1的值就是运算结果
3. 如果是false 表达式2的值就是运算结果

---

## 七.运算符优先级

    优先级     运算符
    1.         . () {} 
    2.         ! ~  ++ --
    3.         * / %
    4.         + -
    5.         << >> >>>
    6.         <  <= > >= instanceof
    7.         == !=  
    8.         &
    9.         ^
    10.        |
    11.        &&
    12.        ||
    13.        ? :
    14.        = += -= *= /= %=. &=


---




## Day04-loop-judgment 判断循环
## 顺序机构

---

## 分支结构

1. if语句
 (1)第一种格式

       if(关系表达式){
       语句体;
       }

执行流程：

 1. 首先计算关系表达式的值
 2. 如果关系表达式的值为ture就执行语句体
 3. 如果关系表达式的值为false就不执行语句体
 4. 继续执行后面的语句

(2)第二种格式

       if(关系表达式){
        语句体1；
       }else{
        语句体2；
       }

执行流程:

 1. 首先计算关系表达式的值
 2. 如果关系表达式的值为ture就执行语句体1
 3. 如果关系表达式的值为false就执行语句体2
 4. 继续执行后面的语句

 (3)第三种格式

       if(关系表达式1){
        语句体1；
       }else if(关系表达式2){
        语句体2；
       }
       ....
       else{
        语句体n +  1;
       }
执行流程：

 1. 首先计算关系表达式1的值
 2. 如果为ture就执行语句体1；如果为false就计算关系表达式2的值
 3. 如果为ture就执行语句体2；如果为false就计算关系表达式3的值
 4. ....
 5. 如果所有的关系表达式的值都为false，就执行语句体n + 1

  switch语句

       switch(表达式){

       case 值1:
       语句体1；
       break;

       case 2:
       语句体2；
       break;

       ....

       default:
       语句体n + 1；
       break;
       }

执行流程:

  1. 首先计算表达式的值，是一个结果
  2. 依次和case后面的值进行比较，如果有的对应的值，就会执行相应的语句体，在执行的过程中，遇到break就跳出。
  3. 如果所有case后面的值和表达式的值都不匹配，就会执行default里面的语句体，然后结束整个switch语句。

格式说明：

 1. 表达式：(将要匹配的值)取值为 byte short int char jdk5以后可以是枚举 jdk7以后可以是String
 2. case 后面跟的是要和表达式进行比较的值(被匹配的值)
 3. break：表示中断，结束的意思，用来结束switch语句
 4. default表示所有情况都不匹配的时候，就该行该处的内容，和if语句的else相似
 5. case后面的值只能是字面量，不能是变量
 6. case给出的值不能重复

case的其他知识点

 1. defaul位置和省略
 2. case穿透
 3. switch新特性
 4. switch和if语句各自使用场景

---

## 循环结构

什么是循环？
重复的做某件事情，具有明确的开始和结束标志
 (3)for循环

       for(初始化语句;条件判断语句;条件控制语句){
              循环语句
       } 

执行流程:

 1. 执行初始化语句
 2. 执行条件判断语句看其结果是true还是false
    如果是false 循环结束
    如果是true  执行循环体语句
 3. 执行条件控制语句、
 4. 回到 2 继续执行条件判断语句

几个核心：

 1. 初始化语句只执行一次
 2. 判断语句为ture 循环继续
 3. 判断语句为false 循环结束

 (2)while循环

      初始化语句；
      while(条件判断语句){
       循环体语句；
       条件控制语句；
      }

执行流程:

 1. 执行初始化语句
 2. 执行条件判断语句看其结果是ture还是false
    如果是false 循环结束
    如果是true  执行循环体语句
 3. 执行条件控制语句、
 4. 回到 2 继续执行条件判断语句

 几个核心：

 1. 初始化语句自执行一次
 2. 判断语句为ture 循环继续
 3. 判断语句为false 循环结束

for和while循环对比:
相同的：
运行规则都是一样的

区别：
for循环中，知道循环次数或者循环范围
while循环中，不知道循环次数和循环范围，只知道循环的结束条件

 (3)do while循环
  
       初始化语句；
       do{
              循环体语句；
              条件控制语句；
       }while(条件判断语句)

执行流程:
先执行后判断

---





## Day05-array 数组

## 一. 什么是数组？

  数组是个容器，可以用来存储同种数据类型的多个值

---

## 二.数组的定义与静态初始化

    数组的格式：
    1.数据类型 [] 数组名    
    eg：int [] array  

     2.数据类型 数组名[]
     eg:
     int array[]

 数组的初始？
 数组的初始化就是在内存中，为数组容器开辟空间，并将数据存入容器当中

 数组的初始化有两种方式
 动态:动态初始化，初始化的只指定数组的长度，有系统为数组分配初始值
 格式：

    数据类型[] 数组名 = new 数据类型[数组长度]；
    eg: int[] arr = new int [3];

1. 静态:

* 初始化：就是在内存中，为数组容器开辟空间，并将数据存入容器当中
* 完整格式：

       数据类型[]数组名 = new 数据类型[] {元素1，元素2 元素3....};
       eg:int[] array00 = new int[]{11,55,44}
       eg:double[] array01 = new duuble[]{11.1 1.11111,55.6};

  在实际开始的，不会写完整格式，把(new 数据类型[])省略不写，写简化后的格式

        数据类型[]数组名 ={元素1，元素2，元素3}；
        eg：int[] array ={11, 22,99}

 注意点：
 数组的长度固定
 数组一但创建完毕了，就不能发生变化

 ---

## 三.元素访问

格式 数组名[索引]；
索引也叫下标，角标
索引的特点 索引从0开始，逐个+1，连续不间断的

---

## 四.数组遍历

 什么是数组遍历?
 将数组的所有的内容取出来，取出来可以进行(打印，求和，判断...)
 注意：遍历是值取出数据的过程，不要理解为遍历，就是打印

 ---

## 五.数组动态初始化

动态初始化 手动指定数组的长度，由系统给定默认初始值推荐使用动态初始化
范围 只明确元素个数，不明确具体的数值，推荐使用动态初始化
举例 使用数组容器来创建键盘录入5个整数

        eg int[] arr={？？？}；
        int [] arr = new int[5]；
  
  静态初始化 手动指定数组元素系统会根据元素个数，计算出数组的长度
范围 需求已经明确了要操作的具体数据，直接静态初始化即可

         eg：将全被数据存入的数组中 77 86 87
         int[] arr ={77，86，87}

 ---

## 六.数组内存图

---

## 七。数组常见问题

 索引越界问题:当访问数组不存在的索引，就会引发索引越界异常

---

## 八.数组常见问题

---




## Day06-method 方法
## 一.么是方法(method)
---
 方法(method)是持续中最小的执行单元
 实际开发中什么时候用到方法呢？
 
 重复的代码，具有独立功能代码可以抽取到方法中
 在实际开发中方法有什么好处？
可以提高代码的复用性
可以提高代码的可维护性
把一些代码打包在一起，用到的时候就调用
方法的定义 把一些代码打包一起，该过程称方法的定义
方法的调用 方法定义后不是直接运行的，需要手动调用才能行的，该过程称方法的调用

 --- 
二.方法的格式

 1. 最简单的方法定义与调用

          方法定义:
          public static void 方法名 (){
          方法体(就是打包的代码);
          }
          eg:
          public static void PlayGema{
          七个打印语句;
          }

         方法的调用:
         PlayGema();
     注意 方法必须先定义后调用

 ---
 
2.  带参数的方法定义和调用

        单个参数的定义                                  
         public static void 方法名(参数){.....}
         eg:              
         public static void method(int number){....} 

         多个参数
         public static void 方法名(参数1,参数2,....){....}
         eg：
         publiic static void method(int number1,int number2,){.....}

         调用                                                
         单个参数的调用                                      
         单个参数:方法名(参数);                               
         eg:
         method(10);                                         
         method(变量1); 

         多个参数方法的调用
         方法名:(参数1,参数2,......);
         eg：                                     getSum(变量1,变量2,....);
         getSum(10,2o...)

 注意:方法调用时，参数的数量与类型必须与方法中小括号里面的变量一一对应，否则程序报错
 形参 全称形式参数 是指方法定义中的参数
 实参 全称实际参数 是指方法调用中的参数 

 ---

 3. 带返回值的方法定义和调用

        格式
        public static 返回值类型 方法名(参数){
        方法体;
         return 返回值; 
         }
         eg 
         public static int getSum(int a , int b){
         int c = a + b 
         return c;
         }

         调用有三种
         1.直接调用    方法名(实参);
         2.赋值调用    整数类型 变量名 = 方法名(实参);
         3.输出调用    System.out.println(方法名 (实参));

---

## 三.方法重载
1. 什么是重载？
 在同一个类中，定一个多个同名的方法，这些方法具有同种功能。
 每一个方法具有不同的参数类型或是参数个数，这些同名的方法，就构成了重载关系
 简单记：
 同一个类中，方法名相同，参数不同的方法，与返回值无关。
 参数不同：个数不同 类型不同 顺序不同

---


 ## 四. 方法的内存图
 1. 方法调用的基本内存原理
 进栈出栈规则
 先进后出
 
 2. 方法传递基本类型内存原理
 变量里存储的是真实的数据
 数据值是存储在自己的空间里的
 特点 赋值给其他变量，也是赋的真实的数据

 3. 方法传递引用类型内存原理
 变量中存储的是地址值
 引用 使用了其他空间的数据
 数据值是存储在其他空间中
 自己空间中存储的是地址值
 特点 赋的其他变量也是赋的地址值

 ---
 


 ## Day07-comprehensive-Practice 综合练习


 ---




 ## Day08-object-oriented
 ## 一.设计对象并使用

- 类和对象

   类是一个又一个能帮助我们解决问题的东西

   类(设计图) 是对象共同特征的描述
   对象       是真实存在在具体东西
   在java中必须先设计类才能获取对象
   如何定义类

      public class 类名{
        1.成员变量(代表属性，一般为名词)
        2.成员方法(代表行为，一般为动词)
        3.构造器
        4.代码块
        5.内部类
      }

      eg:
      
      public class phone {
        //属性 (成员变量)
        String brand;
        double price;

        //行为(方法)
        public void call(){

        }
        public void playGame(){

        }
      }

    如何得到类的对象

      类名 对象名 = new 类名();

      eg:

      phone p    = new phone();

    如何使用对象

      访问属性:对象名.成员变量

      访问行为:对象名.方法名(....)

小结：

1. 类和对象是什么？
     类：是共同特征的描述(设计图); 对象：是具体存在在具实例
2. 如何得到对象？

       public class 类名{
        1.成员变量(代表属性的，一般是名词)
        2.成员方法(代表行为的，一般是动词)
        }

    创建对象

      类名 对象名 = new 类名();

3. 拿到对象后能做什么

     1.访问属性:对象.成员变量;
     2.访问行为:对象名.方法名(...)

---

- 类的补充和注意事项
用来描述一类事物的类，专业叫做：javaBean类
 在javaBean类，是不写main方法的
在以前，编写main方法的类，叫测试类
 我们可以在测试类中创建javaBean类的对象并进行赋值调用
类名的首字母建议大写，见名知意驼峰命名。
 一个java文件中可以定义多个class，且只能一个类是public修饰的，而且public修饰的类名必须成为代码的文件名。实际开发中建议还是一个文件定义一个class类
成员变量完整定义格式是

       修饰符 数据类型 变量名 = 初始值；

一般无需指定初始化值 存在默认值

---

## 二.封装

1. 什么是封装?
 告诉我们，如何正确的设计对象的属性和方法
 原则：对象代表什么，就得封装对应的数据，并提供数据对应的行为
2. 封装的好处
 ·让编程变得简单
 ·降低了学习成本

private关键字是一个权限修饰符
可以修饰成员(成员变量 成员方法)
被private修饰的成员只能在本类中才能访问
针对private修饰的变量如果需要被其他类使用，提供相应的操作
提供"setXxx(参数)"方法，用于给成员变量赋值，方法用publi修饰
提供"getXxx(参数)"方法，用于获取成员变量的值方法用public修饰

针对每一个私有化变量，都要提供set和get方法

1. setXXX(setter)方法，给成员变量赋值

格式为：

    public void set属性名首字母大写(数据类型 属性名) {
    this.属性名 = 属性名
     }

2.get(getter)方法，给成员对外提供成员变量的值
格式为:

    public 数据类型 get属性名字母大写(){
    return 属性名;
    }

---

## 三.this关键字

局部变量 定义在方法里面
成员变量 方法的外面类的里面
就近原则
this的作用，区分局部变量和成员变量

---

## 四.构造方法

构造方法也叫构造器，构造函数
作用：在创建对象时候给成员变量进行赋值的

1. 无参构造

       public 类名(){}
    


       修饰符 类名(参数){
       方法体；
       }
       
特点：

1. 方法名与类名相同，大小写也要一致
2. 没有返回值类型，连void都没有
3. 没有具体的返回值(不能由return带回结果数据)
执行时机
1.创建对象的时候由虚拟机调用，不能手动调用构造方法
2. 每次创建一次对象，就会调用一次构造方法\
构造方法注意事项
1. 构造方法的定义
 ·如果没有定义构造方法，系统将给出一个默认的无参构造方法
 ·如果定义一个构造方法，系统将不再提供默认的构造方法
2. 构造方法的重载
 ·带参的构造方法，和无参构造方法，两者的方法名相同，但参数不同，这叫做构造方法的重载
3. 推荐使用方式
 ·无论是否使用，都手动书写无参构造方法和带参构造方法

小结：

1. 构造方法的作用？
 ·创建对象的时候，由虚拟机自动调用，给成员变量进行初始化的
2. 构造方法有几种？各自的作用是什么？
 ·无参构造方法：初始化对象时，成员变量的数据均采用默认值
 ·有参构造方法：在初始化对象的时候，同时可以为对象进行赋值
3. 构造方法有那些注意事项
 ·任何类定义出来时，默认就自带了无参构造器，写不写都有
 ·一旦定义了有参数的构造器，无参构造器就没有了，此时就需要自己写无参数构造器
 ·建议在任何时候的手动写上空参和带全部参数的构造方法

 ---

## 标准的javaBean类

 1. 类名需要见名知意，驼峰命名
 2. 成员变量使用private修饰
 3. 提供至少两个构造方法
  · 无参构造方法
  ·带全部参数的构造方法
 4. 成员方法
 ·提供一个成员变量setXxx()/getXxx()
 · 如果还有其他行为，也需要写上

## 对象的内存图

---

## 成员变量&局部变量

---





## Day09-object-oriented-test 面向对象练习


---




## Day10-string 字符串

## 一.API

  1. 什么是api？
  API(Application Programming Interface)：引用程序编辑接口
  简单理解就是：API就是别人已经写好的东西，我们不需要自己编写，直接使用即可。
  java API指的是JDK中提供的各种各样功能的java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只要学习这些类如何使用即可。
  2. 什么是API帮助文档？
  帮助开发人员更好的使用API和查询API的工具。

---

## 一.String概述

1. String是java定义好的一个类，定义在java.lang包里的，所以使用时不需要导包。
2. java程序所有字符串文字（如"123"）都被实为此类的对象。
3. 字符串不可改变，他们的值在创建后不不能被改改。

---

## 1.创建String对象的两中方式

1. 直接赋值的方法

       eg: String si = "abc";
2. new空参构造的方法

       构造方法               构造说明
       public String ()      创建空白字符串，不含任何内容
       public String(String original) 根据传输的字符串，创建字符串对象
       public String(char [] chs) 根据字符数组， 创建字符串对象
       public String(byte [] chs) 根据字节数组，创建字符串对象

---

## 2.字符串的比较

1. ==比的是什么？
基本数据类型：比的是具体的值
引用数据类型·：比的是地址值
2. 两个方法

 boolean equals方法(要比较都是字符串) 完全一样才是true，否则false
 boolean equalsslgnoreCase(要比较的字符串) 忽略大小写

---

## 3.遍历字符串

    public char charAt(int index)，根据索引返回字符
    public int length 返回·字符串的长度
  
    数组长度 数组名.length
    字符长度 字符串对象.lenght()

---

## 4.截取字符串

    punlic substring(int beginlndex, int endlndex)截取
    注意点包头不包尾 包在不包右
    只有返回值才是截取的小段
    String substring(int begindex)截取到末尾

---

## 5.替换字符串

    string reqlace(旧值，新值) 替换
    注意
      只有返回值才是替换的结果
---

## 二. StringBuider

1. 什么是StringBuilder
  StrigBuilder可以看做一个容器，创建之后内容是可变的
  作用：可以提供字符串的操作效率

       StringBuilder构造方法
       方法名                     说明
       public StringBulider()     创建一个空白可变字符串对象 不含有任何内容
       StringBuilder(String str)  根据字符串的内容 来创建可变字符串对象
      
       StringBuilder常用方法
       方法名                                   说明
       public StringBuilder append (任意类型)   添加对象 并返回对象本身
       public StringBuilder reverser() 翻转容器中的内容
       public int length()             返回长度(字符出现的个数)
       public String toString()  通过toString()就可以实现把StringBuilder转换String

链式编程 当我们调用一个方法的时候 不需要用变量接受他们的结果 可以继续调用其他的方法

---

## 三. StringJoiner

1. StringJoiner跟StringBuilder一样 也可以看做一个容器 创建之后里面的内容是可变的

作用提高做字符串操作效率，且编写简洁

    构造方法
    方法名   说明
    public StringJoinr(间隔符)  创建一个StringJoiner对象 指定拼接时的间隔符号
    public StringJoiner(间隔符号，开始符号，结束符号) 创建一个StringJoiner对象 指定间隔符号，开始符号，结束符号

    成员方法
    方法名      说明
    public StringJoiner add(添加内容) 添加数据 并返回对象本身
    public int length() 返回长度(字符出现的个数)
    public String toString() 返回一个字符串 (该字符串就是拼接之后的结果)
总结

1. String
表示字符串的类 定义了很多字符串的方法Q
2. StringBuilder
一个会可变的字符串操作容器
可以高效的拼接字符串 还可以将字符串容器里面的内容反转
3. StringJoiner
JDK8出现的可变操作字符串的容器 可以高效 方面拼接字符串

---

## 四. 字符串原理

1. 扩展底层原理 字符串存储内存原理
  直接赋值会复用字符串常量池中的
  new出来的不会复用，而是开辟了一个小空间
2. 扩展底层原理 ==号比的到底是什么
  基本数据类型 比的是数据值
  引用数据类型 比的是地址值
3. 扩展底层原理   字符串拼接底层原理
   如果没有变量参与 都是字符串直接相加 编译之后就是拼接之后的结果 会复用串池中的字符串
如果有变量参与 会创建新的字符串 浪费内存
4. 扩展底层原理 StringBuilder提高效率原理图
   所有拼接的内容都会往StringBuilder里放不会创建很多无用空间 节约内存
5. 扩展底层原理 StringBuilder源码分析
  默认创建一个长度为16的字节数组
  添加的内容长度小于16 直接存
  添加的内容大于16扩容(原来容量*2+2)
  如果扩容之后还不够 以实际长度为准

  ---





## Day11-arraylist  集合
---

## 一.为什么要用集合

1. 区别：
长度：
  数组长度固定
  集合长度可变
存储类型：
  数组能存基本数据类型和引用数据类型
  集合只能存引用数据类型，如果要存基本数据类型需要把他们变成相应的包装类

---

## 二.集合

1. 泛型：限定集合存储的数据类型
2. . 怎么创建集合

        JDK7以后的写法
        构造方法
        ArrayList<里面写泛型> list = new ArrayList<>();

        成员方法 增 删 改 查
        方法名     说明
        boolean add(E e)  添加元素，返回值表示是否添加成功
        boolean remove(E e) 删除指定元素，返回值表示是否删除成功
        E remove(int index) 删除指定索引元素，返回被删除元素
        E set(int index,E e) 修改指定索引下的元素，返回原来的元素
        E get(int index)  获取指定索引的元素
        int siz() 集合的长度，也就是集合中元素的个数
3. 注意：  
·此时创建的的是ArrayList集合对象，二ArrayList是java已经写好的类
·这个类在底层做了一些处理
·打印对象不是地址值，而是集合中存储数据内容
·在展示的时候会拿着[]把所有的数据进行包裹

---

## 三.综合练习

1.基本数据类型对应的包装类

    byte       --> Byte
    short      --> Short
    char       --> Character
    int        --> Integer
    long       --> Long
    float      --> Float
    double     --->Double
    boolean    --> Boolean

---





## Day12-stundentUpgradedversion 学生管理系统升级版

---



## Day13-Advancedobject-orientedprogramming(一) 面向对象进(一) 

## 一.static
1. static表示静态的意思，是java的修饰符可以修饰成员变量，也可以修饰成员方法
  被static修饰的成员变量，叫静态变量。                   被static修饰的成员方法

特点：                                                   多用于测试类和工具类
 - 被该类所有对象共享                                     在javabean类很少会用到
 - 不属于对象，属于类
 - 静态变量是随类的加载而。优先于对象出现的         

 调用方式：                                                 调用方式;
 - 类名调用(推荐)                                           类名调用(推荐)
 - 对象调用                                                 对象调用
    
2. static内存图    

3. JavaBean类： 测试类 工具类
- JavaBean类 用于描述这一事物的类 比如 Stundent Teacher Dog Cat类 
  在书写JavaBean类的时候要私有化成员变量，书写空参和带全参的构造方法，并针对每一个私有化成员
  变量提供对应的set和get方法，如果有额外的行为，比如：sleep eat，还要写额外的成员方法。
- 测试类：用类检查其他类是否书写正确，带用main方法的类，是秩序的主入口。
- 工具类：不是用于描述这一类事物的类，而是帮我们做一些事物的类
  在书写工具类的规则
  1. 类名要见名知意
  2. 私有化构造方法 私有化构造方法在外界不能创建这个的对象了，工具类不是描述一类事物的
     创建它的对象没有任何意义。
  3. 方法都定义为静态的方面调用

4. 注意事项
   - 静态方法知能访问静态变量和静态方法
   - 非静态的方法可以访问静态变量或者静态方法，也可以访问非静态的成方法法和成员变量
   - 静态方法中没有this关键字
    总结：
    静态方法中，只能访静态
    非静态方法可以访问所有
    静态方法中没有this关键字
    一.从代码成面理解
    笔记ing 
    二.从内存成面理解
    笔记ing
5. 重新认识main

        public class HelloWorld{
           public static void main (String [] args){


           }
       }
       public   被JVM调用    访问权限足够大
       static   被JVM调用    不用创建对象 直接用类名访问
                             因为main方法是静态的，所以测试类中的其他方法也需要是静态的。
       void     被JVM调用     不需要给返回值
       main    一个通用名称   虽然不是关键字。但是被JVM识别
       String [] args         以前用于键盘录入数据的，现在没用
 
---

## 二.继承
1. 什么是继承？继承的好处？
   继承是面向对象的三大特征之一，可以让类跟类之间产生父子关系
   可以把多个子类中重复的代码抽取到父类中，子类可以直接使用，减少代码的冗余，提供代码复用性。
2. 继承的格式

        public class 子类 extends(继承) 父类{}

3. 继承后子类的特点？
   子类可以得到父类的属性和行为，子类可以使用。
   子类可以在父类的基础上新增其他的方法，让子类更强大。
   
      - java只能但继承，不支持多继承，但可以多层继承。
      - java中所有的类直接或间接继承Object.
      - 子类只能访问父类中非私有的成员。
      - 能独立完成继承体系的设计。
   
4. 子类到底继承父类那些内容(内存图/内存分析工具)
         
       构造方法      非私有(不能)     private(不能)
       成员变量      非私有(能)       private(虽然继承下来了，但是不能直接调用)
       构造方法      虚方法表(能)     否则(不能)
       
         成员方法调用规则：
         在最顶级父类开始设立，虚方法表，只要方法满足一下要求，这样的方法叫做虚方法。
         java会把这些虚方法抽取处来，放到虚方法表中。在继承的时候，父类C会把自己的虚方法表交给儿子，在B类会有自己的虚方法表，在C类的基础上添加自己类中的虚方法，那么A在基础B的时候，
         会把自己的需方法表交给儿A子，在A中也有自己的需方法表，会在B的基础上，在自己自己类中的虚方法。
         1. 方法不能用非private修饰
         2. 方法不能用非static修饰
         3. 方法不能用非final修饰
      
       总结：
       1. 构造方法：不管是什么修饰符子类都不能继承
       2. 成员变量：不类是什么修饰符子类都等被继承
       3. 成员方法: 如果说当前方法能被添加到虚方法表中，这个方法能被子类继承下来，否则不能。

       注意：
       能被继承和能不能直接使用是令一回事


5. 继承中：成员变量访问特点：
   
       1. 继承中成员变量访问特点：就近原则；
       先在本类局部位子上找，如果没有那么在本类成员位置上找，在没有在去到父类的成员位置上找。逐级往上找。

       2. 如果重名了怎么办？
       sout(name)         如果直接调用name，会本类从局部位置开始往上找
       sout(this.name)    如果是this.name,  会从本类成员位置开始往上找
       sout(super.name)   如果是super.name, 会从父类成员位置往上找

6. 继承中： 成员方法访问特点：

       直接调用满足就近原则：谁离我近我就用谁，
       用super调用直接访问父类。 

7.  继承中：  构造方法的访问特点：
    
        - 父类中的构造方法不会被子类继承
        - 子类中所有构造方法默认先访问父类中的无参构造，在执行自己
        为什么？
        - 子类在初始的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类无法完成使用父类使用父类数据。 
        - 子类初始化之前，一定要调用父类构造方法先完成父类数据空间初始化。
        这么调用构造方法？
        -  子类构造方法第一行默认都是：super();不写也存在，且必须在第一行。
        -  如果想调用父类有参构造，必须手动写super进行调用

8. 方法重写： 
       
       1. 方法重写： 
        - 方法重写：当父类的方法不能满足子类现在的需求的时候时，需要进行方法重写
       2. 书写格式：
        - 在继承体系中，子类出现和父类一模一样的方法声明，我们就称子类这个方法是重写方法。

       3. @Override重写注解：
        - @Override是放在重写后的方法上，校验方法重写是语法是否正确。
        - 加上注解如果有红色～，表示语法错误。
        - 建议重写方法都加上@Override注解，代码安全，优雅。
       4. 方法重写注意事项：
        - 重写方法的名称、形参列表必须与父类中的一致。
        - 子类重写父类方法时，访问权限子类必须大于父类
        - 子类重写父类方法时，返回值必须小于等于父类
        - 建议：重写方法时尽量和父类保持一致
        - 只要添加的虚方法表中的方法才能被重写
       

 

---

 


## Day14-Advancedobject-orientedprogramming(二)  面向对象进(二)

## 一.多态
1. 什么是多态？
   同种类型的对象，表现出的不同形态。
2. 多态的表现形式\
父类类型 对象名称 = 子类对象；
3. 多态的前提
- 有继承关系、
- 有父类引子类关系(多态方法创建对象)
   
      Fu f = new zi ();

4. 多态的好处
- 使用父类类型作为参数，可以接受所用子类对象
- 体现多态的扩展性和便利性
5. 多态调用成员特点
- 变量调用：编译看左边，运行也看左边。

      Fu f = new Zi ();

      - 编译看左(父类)：用javac编译代的时候，会看左边的父类有没有这个变量，如果有编译成功，否则编译失败。

      - 运行也看左边(父类)：java运行代码的时候，实际获取的就是父类中的成员变量的值。

      - 方法调用：编译看左边，运行看右边.

      Fu f = new Zi ();
      a.show();

      - 编译看左边(父类)：用java编译代码的时候，会看左边的父类有没有这个方法，如果有编译成功，否则编译失败。
      - 运行看右边(子类)：java运行的时候，实际上运行的是子类中的方法。
6. 多态调用的内存图解

7. 多态的优势和弊端

      -  多态的优势：方法中，使用父类作为参数，可以接受所用子类对象
            
      

      2. 多态的弊端：不能使用子类的特有功能
      3. 引用数据类型转换类型有几种
         自动转换 强制转换
      4. 强制类型转换能解决什么问题
       - 可以转成真正的子类类型，从而调用子类独有功能
       - 转换类型与真实对象类型不一致会报错
       - 转换的的时候用instanceof关键字进行判断

---

## 二.包、final、权限修饰符、代码块
### 1. 包 

1. 包的作用：
   - 包就是文件夹，用来管理不同功能的java类
2. 包名抒写格式：
   - 公司域名地址反写+包的作用，需要全部英文小写，见名知意思
3. 什么是全类名？
   - 包名+类名
4. 什么时候需要导包？什么时候不需要导包？
   - 使用同一个包类时，不需要导包
   - 使用java.lang包中的类时，不需要导包
   - 其他情况都需要导包
   - 如果同时使用两个包中的同名类，需要用全类名

### 2. final关键字
1. final修饰方法：表示最终方法，不能被重写。
2. final修饰类：  表示最终类，不能被修改。
3. 修饰变量：     表示常量，只能赋值一次，不能被修改。
4. 常量：
    在数据开发中，常量一般作为系统的配置信息，方面维护，提高可读性。
    常量的命名规则：
       - 单个单词，全部小写。
       - 多个单词：全部大写，用下划线隔开
     细节：
        - 基本数据类型：   变量的值不能被修改。
        - 引用数据类型：  地址在不能被修改，内部的属性值可以修改。

### 3. 权限修饰符
1. 权限修饰符：是用来控制一个成员变量能够访问的范围的。
   - 可以修饰：成员变量、方法、构造方法，内部类
2. 权限修饰符分类
   有四种作用范围有小到大(private < 空着不写 < protected < public )

3.  权限修饰符的使用规则
   在实际开发中，一般只用private和public
   - 成员变量私有
   - 方法名公开
   特例:如果方法中的代码是抽取其他方法中共性代码， 这个方法一般也私有

### 4. 代码块
1. 代码块发分类
   局部代码块、构造代码块、静态代码块

2. 局部代码块的作用
   提前结束变量的生命周期(已淘汰)
3. 构造代码块的作用
   抽取构造方法中重复代码(不够灵活)
4. 静态代码块的作用

         格式：
               static(方法体)
数据的初始化(重点)


---



## Day15-Advancedobject-orientedprogramming(三) 面向对象进(三)

## 四.抽象类
1. 抽象类的作用是什么样的？
   - 抽取共性为，无法确定方法体，就把方法体。就把方法体定义为抽象的。
   - 强制让子类按照莫中格式重写。
   - 抽象方法所在的类，必须是抽象类。
2. 抽象类和抽象方法的定义格式？
   
       public abstract 返回值类型 方法名(参数)；

       public abstract class 类名{}

3. 继承抽象类有那些要注意？
   - 抽象类不能实例化
   - 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类
   - 可以有构造方法
   抽象类的子类
   - 要么重写抽象类中所要抽象方法
   - 要么是抽象类
## 五.接口
1. 接口的定义
   - 接口用关键字interface来定义
    
         public interface 接口名 {}
   - 接口不能示例化
   - 接口和类之间是实现关系，通过implements关键字表示
     
         public class 类名 implements 接口名{}
   - 接口的子类(是实现类)
     要么重写接口中所要抽象方法
     要么是抽象类
2. 注意：
   - 接口和类实现关系，可以单实现，可以多实现

         public class 类名 implement 接口名1 接口名2 {}
   - 实现类可以继承一个类的同时实现多个接口
           
         public class 类名 extendss 父类 implements 接口名1，接口名2 

3. 接口中成员的特点
   - 成员变量
     接口中的成员变量自能是常量
     默认修饰符； 

          public static final 
          final:接口是一种规则，规则不能发生改变的，所以接口里面面的成员变量是常量,会用final修饰。
          static:方法接口的调用，用接口名点(.)常量的名称就可以了。
          public 表示公共的就表示在所有的地方都可以使用接口。
          即使没有写java也会自动加上

   - 构造方法
     没有
   - 成员方法
     在jdk以前：只能定义抽象f方法
     默认修饰符

            public absstract
      在jdk8的新特性： 接口中可以定义有方法体的方法
      在jdk9的新特性： 接口中可以定义私有方法

4. 接口和类之间的关系
   - 类和类之间的关系
     继承关系，只能单继承，不能多继承，可以多层继承
   - 类和接口之间的关系
     实现关系，可以单实现，也可以多实现，还可以继承一个类的同时实现多个接口(如果实现了多个接口，要重写所要的重新方法)
   - 接口和接口之间的关系
     继承关系，可以单继承。也可以多继承(如果实现类实现了最下面的子接口的话，那么要重写所要体系中的所有的抽象方法)

5. jdk8 开始接口新增的方法
   - jdk7以前：只能定义默认方法

     - 允许在接口中定义默认方法，需要用defult关键字来修饰
     - 作用：解决接口升级的问题

     接口中默认方法定义格式：
        格式

         public default 返回值 方法名(参数){}

         示例

         public default void show(){}

    接口中默认方法的注意事项
    - 默认方法不是抽象方法，所以不强制被重写。但是如果被重写，重写的时候去掉default关键字
    - public可以省略，但default不能省略
    - 如果实现了多个接口，多个接口中存在相同的名字的默认方法，子类就必须对该方法进行重新

   - jdk8的新特性：接口中可以定义有方法体的方法(默认静态)
     - 允许在接口中定义抽象方法，需要用static修饰

   接口中静态方法定义格式：

          public static 返回值类型  方法名(参数){}

    示例：
          public static void show(){}

    接口中静态方法的注意事项：
    - 静态方法只能通过接口名调用，不能通过实现类名或者用对象名调用
    - public 可以省略，但static不能省略
     
   - jdk9的新特性：接口中可以定义私有方法

           格式1：
           
           private 返回值类型 方法名(参数表){}

           范例：

           private void show(){}

          格式2：

          private static 返回值类型 方法名(参数类型){}

          范例：

          public static void show(){}


6. 私有方法有两种： 普通私有方法。静态私有方法   

接口的应用
- 接口代表规则，是行为的抽象，想让哪个类拥有一个行为，就让这个类实现对应的接口就行了。
- 当一个方法参数是接口时，可以传递接口所要实现类的对象，这个方式称之为接口多态

7. 适配器设计模式
- 适配器(Design pattern)是一套被反复使用，多人知晓的、经过分类编目的、代码设计经验总结。
使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。 
- 简单理解设计模式就是各种套路

适配器设计模式：就是解决接口和接口实现类之间的矛盾
- 当一个接口中抽象类过多，但时我只要使用其中一部分的时候，就可以使用适配器设计模式

- 书写步骤
   编写中间类 接口名Adapter实现对应接口
   对接口的抽象方法进行空实现
   让真在的实现类继承中间类，并重写需要的方法
   为了避免其他类创建适配器类的对象，中间的适配器类用abstract进行修饰

---

## 七.内部类
1. 什么是内部类？
   写在一个类的里面的类就叫做内部类
2. 什么时候用到内部类？
   B类事物是A类的一部分，且B单独存在没有意义，就可以用到内部类‘
   比如：汽车发动机，ArrayList迭代器。
3. 内部类的分类？
   内部内部类、静态内部类、局部内部类、匿名内部类

### 1. 内部类

4. 什么是成员内部类？
   写在成员位置的，属于外部的成员。
5. 获取成员内部对象的两种方式？
   方式一：当成员内部类被private修饰时，
   在外部雷编写方法，对外提供内部类的对象
   方式二、当成员变量被非私有修饰时，直接创建对象。
         直接创建格式：
         外部类的类名.内部类的类名 对象名 = 外部类对象。内部类对象；
         Outer.Inner oi = new Outer().new Inner();
6. 外部类成员变量和内部类成员变量重名时，在内部类如何访问？

         sout(outer.this.变量名);

7. 成员内部类可以被一些修饰符所修饰的，比如：public(空着不写) 默认 protected static等 

8. 在成员内部类的里面，jdk16之前不能定义静态变量，在jdk16开始才定义静态变量

### 2. 静态内部类
9. 什么是静态内部类
   前面用static关键字修饰的，静态内部类是一种特殊的成员内部类。
    注意：静态内部类只能访问外部类中的静态变量和金泰方法，如果想要访问非静态的需要创建对象。
10. 直接创建静态内部类对象的方式？

            创建静态内部类对象的格式：
            外部类名.内部类名 对象名 = new 外部类名。内部类名();
             Outer.Inner oi = new Outer.Innwe();


11. 如何调用静态内部类种的方法？
    非静态的方法：先创建对象，用对象调用。
    静态方法：    外部类名。内部类类名。方法名();


### 3. 局部内部类
12. 将内部类定义在方法里面就叫做局部内部类，类似于方法里面的局部变量。
13. 外界无法直接使用需要在方法内部创建对象并使用。变量
14. 该类可以直接访问外部类的成员，也可以访问方法内的局部

### 3. 匿名内部类
15. 什么是匿名内部类？
    隐藏了名字的内部类，可以写在成员位置，与可以写在成员位置。
16. 匿名内部类书写故事？

          new 类名或者接口名(){
            重写方法；
          }；

17. 格式细节
    包括了继承或实现，方法重写，创建对象。
    整体就是一个类的子类对象或者接口的实现对

18. 使用场景
    当方法的参数是接口或者类时，以接口为例，
    可以传递这个接口的实现类对象，
    如果实现类只要使用一次，就可以用匿名内部类简化代码
---


## 八.拼图小游戏

---




### Day16 tage-project-puzzle-game-a(一) 拼图小游戏(一) 


---




## Day17  tage-project-puzzle-game-Logical-implementation(二) 拼图小游戏-逻辑实现(二)


---



## Day18-Common-api(一) 常用api(一) 

## 1.Math
1. Math帮助我们进行数学计算的工具类

 

2. 里面的方法都是静态的
常见的方法如下：
      
       方法名                                                说明
       public static int        abs(int a)                  获取参数绝对值
       public static double     ceil(double a )             向上取整
       public static double     floor(double a)             向下取整
       public static int        round(float)a               四舍五入
       public static int        max  (int a , int b)        获取两个int值中的较  大值
       public static double     pow  (double a ,double b)   返回a的次幂的值
       public static double     random()                    返回double的随机  值，范围[0.0,1.0）


---

## 2.Sysrem
1. System:也是一个工具类，提供了一些与系统相关的方法
2. 时间原点：1970年1月1日0.0.0，我国在东巴区，有八个小时的时差
3. 1秒=1000毫米
4. 常见的方法

       方法名                                              说明
       public static void exit(int static)                 终止当前运行的java虚拟机
       public static long currentTimeMillis()              返回当前系统时间毫秒值形式
       public static void arraycopy(数据源数组，起始索引，目的地索引，起始索引，拷贝个数)    拷贝数组

---

## 3.Runtime
                  
       方法名                                              说明
       public     static Runtime getRuntime()              当前系统环境运行对象
       public void exit (int static)                       停止虚拟机
       public int  availableProcessoors()                  获取CPU线程数
       public log  maxMemory                               JVM能从系统中获取总内存大小(单位 byte字节)
       public log  totalMemory                               JVM能已经从系统中获取总内存大小(单位 byte字节)
       public log  freeMemory                               JVM剩余内存大小(单位 byte字节)
       public Process exec (string comand)                  运行cmd命令

---

## 4.Object
5. Object是java顶级父类所有类直接或间接继承于Object类
       
        方法名                                             说明
        publicc String toString()                          返回对象字符串表示形式
        public boolean equals(Object obj)                  比较两个对象是否相等
        protect Object clone(int a)                        对象克隆 


---

## 5.Objects是java的一个工具类
  
       方法名                                              说明
       public static boolean equals(Object a, Object b)    先做非空判断，比较两个对象
       public static boolean isNull(Object obj)            判断对象是否为Null,为null返回true,反之
       public static boolean nonNull(Object obj)            判断对象是否为Null,跟isnull结果相反

---

## 6.BigInteger构造方法
6. 如果BigInteger表示的数字没有超出long的范围，可以用静态方法获取
7. 如果BigInteger表示的数字超出long的范围，可以用构造方法获取
8. 对象一旦创建，BigInteger内部记录的值不能发生变化
9. 只要进行了计算都会产生新的BigInteger对象


       方法名                                                说明
       public BigInteger (int num, Random rnd)               获取随机大整数，范围[ 0~  2 的 num 次方 - 1]
       public BigInteger(String val)                         获取指定的大整数
       public BigInteger(String val , int radix)             获取指定进制的大整数

       静态构造
       public static BigInteger valOf(log val)                静态方法获取BigInteger对象，内部有优化
        
       构造方法
       public BigInteger add(BigInteger val)                  加法
       public BigInteger subtract(BigInteger val)             减法
       public BigIntefer multiply(bigInteger val)             乘法
       public BigInteger divide(BigInteger val)               除法 获取商
       public BigInteger divideAndRemaindeer(BigInteger val)               除法 获取商和余数
       public boolean equals(Object x)                        比较是否相同
       public BigInteger  pow(int exponent)                    次幂
       public BigInteger  max/min(BigInteger val)              返回较大大值/返回较小值
       public intValue(BigInteger val)                          转为int类型的整数，超出范围的数据有误    

10. BigDecimal的作用是说明
    表示加大的小数和解决小数运算精度失真的问题
11. BigDecimal对象如何获取
    
        BigDecimal bd1 = new BigDecimal("较大的小数")
       BigDecimal bd2 = BigDecimal.valueOf(0.01);

12. 常见的操作

       构造方法
       public BigDecimal add(BigInteger val)                  加法
       public BigDecimal subtract(BigInteger val)             减法
       public BigDecimal multiply(bigInteger val)             乘法
       public BigDecimal divide(BigInteger val)               除法  
       public BigDecimal divide(BigInteger val,精确几位，舍入模式)               除法  


---

## 7. 正则表达式
13. 正则表达式的作用
   作用一：校验字符串是否满足规则
   作用二：在一段文本中查找满足要求的内容

14. 常用规则

       字符类(只匹配一个字符)

        [abc]          只能是a.b,或c
        [^abc]         除了a,b,c之外的任何字符
        [a-zA-Z]       a到z A到Z 包括  范围
        [a-d[m-p]]     a到d 或m到p
        [a-z&&[def]]   d,e或(交集)
        [a-z&&[^bc]]   a-z,除了b和c(等同于[ad-z])
        [a-z&&[^m-pq]] a到z，除了m-p(等同于[a-lq-z])


        预定义字符(只匹配一个字符)
       
        .                任何字符
        \d               一个数字：[0-9]
        \D               非数字：  [0-9]
        \s               一个空白字符：[\t\n\xOB\f\r]
        \S               非空白字符    [^\s]
        \w               [a-zA-Z_0-9]英文、数字、下划线
        \W               [^\W]一个非单词字符

        数量词

        X?               x,一次，或零次
        X*               X，零次，或多次
        X+               X，一次  或多次
        X{n}             X,正好n次
        X{N,}            X，至少n次
        X{n,m}           X，至少n次，但不超过m次

        正则表达式在字符串方法中的使用

        方法名                                                               说明
        public String [] (String regex)                                      判断字符串是否满足正则表达式的规则
        public String relaceAll(String regex,String newStr)                  按照正则表达式规则进行替换
        public String [] (String regex)                                      按照正则表达式的规则进行切割
       
15. 什么是分组？
    分组就是一个小括号

16. 正则表达式分组有两中
    捕获分组和非捕获分组

17.  捕获分组(默认)
     可以获取每组中的内容反复使用
18. 组号的特点
    从1开始，连续不间断
    以左括号为基准，最左边的是第一组
19. 非捕获分组
    分组之后不需要本组数据，仅仅把数据括起来
    (? :) (?=) (?!)都是非捕获分组

---




## Day19-Common-api(二) 常用api(二) 


## 1. 时间相关的知识
1. 时间标准时间
   格林尼治时间/格林威治时间(Greenwich Mean Time) 简称GMT 现在已弃用
   目前世界标时间(UTC)已替换为:原子钟
2. 中国标准时间：世界标准时间加8小时

---

## JDK7以前的时间类

### 1.Date
3. 如何创建日期对象

            空参构造

            Date date = new Date();

            带参构造

 
           Date date = new Date(zhidig)
2. 如何修改瞬间的毫秒值

           setTime(毫秒值)

3. 如何获取时间对象的毫秒值

            getTime();

---

### 2.SimpleDateFormat
4. 构造方法

            构造方法                                                    说明
            public SimpleDateFormat()                                  构造一个SimpleDateFormat，使用默认格式
            public SimpleDateFormat(String pattern)                    构造一个SimpleDateFormat，使用指定 格式
            方法名                                                      说明
             public final String format(Date ,date)                     格式化(日期 字符串)
             public Date prse(String sourse)                            解析(字符串 日期)

5. SimpleDateFormat两个作用
   格式化和解析
6. 如何指定格式
   yyyy年mm月dd日 HH:mm:dd:ss

---

7. Calendar表示什么
   表示一个时间的日历对象
   Calwnder代表了系统当前时间的日历对象，可以单独修改、获取时间中的年月日
   细节
   Calender是一个抽象类，不能直接创建对象

8. 如何获取对象
   通过getInstance方法获取对象

            方法名                                 说明
            public static Calender getInstance()   获取当前时间日历对象

9. 常见方法

            方法名                                 说明
            public final Date getTime()            获取日历对象
            public final setTime(Date date)        给日历设置对象
            public long getTimeInMillis()          拿到时间毫秒值
            public void setTimeInMillis(long millis) 给日历设置毫秒值
            public int get(int field)                取日历中的某个字段名
            public void set(int field,int value)     修改日历的某个字段名信息
            public void add(int field,int amount)    为某个字段名曾加或减少指定信息
    
10. 细节
    日历类中的月份范围0~11
    日历类中的星期的特点星期日是一周的第一天

---

## 2.jdk8的射击类

### 1.时间类(Date)

            1. Zomeld:时区
            方法名                     说明
            static set<String> getAvailableZoneIds()  获取java中支持的所有时区
            static ZoneId systemDefault()              获取系统默认时区
            static ZoneId of (String zoneId)           获取一个指定的时区

            2. Instrant:时间戳
            方法名                     说明
            static Instant now()       获取当前时间的Instant对象(标准时间)
            static Instant ofXXX(long epochMilli)  根据(秒 毫秒 纳秒)获取Imstant对象
            ZoneDateTime atZone(ZoneId zone)        指定时区
            boolean isXXX(Instant otherInstant)     判断系列的方法
            Instart miusXxx(long millisToSubtract)  减少时间系列的方法
            Instart PlusXxx(long millisToSubtract)  曾加时间系列的方法

            3. ZoneDateTime: 带时区的时间
            方法名                                    说明
            static ZonedDateTime now()                获取当前时间的ZonedDateTime对象
            static ZoneDateTime offxxx()               获取指定时间的ZonedDateTime对象
            ZonedDateTime withXxx(时间)                 修改时间系列的方法
            ZonedDateTime minusXxx(时间)                减少时间系列的方法
            ZonedDateTime plusXxx(时间)                 增加时间系列的方法


---

### 2.日期格式化类(SimpleDateFormat)

          1. DateTimeFormatter 用于时间的格式化和解析

          方法名                                          说明
          static DateTimeFormatter ofPttern(格式)         获取格式对象
          String format(时间对象)                         按照指定格式格式化

---


### 3.日历类(Calemder)

         1. LocalDate 年月日
         2. LocalTime 时分秒纳秒
         3. LocalDateTime 年月日 时分秒纳秒 

         方法名                                          说明
         static xxx now()                               获取当前时间的ZonedDateTime对象
         static xxx offxxx()                            获取指定时间对象
         get开头的方法                                   获取年月日 时分秒纳秒
         isxxBefore() isafter                           比较两个local对象
          withX开头的                修改时间系列的方法
          minus开头的                减少时间系列的方法
          plusX开头的                增加时间系列的方法

---

### 4.工具类

         1. Duration:用于计算两个 "时间" 间隔 (秒，纳秒)
         2. Period  :用于计算两个 "日期" 间隔 (年月日)
         3. ChronoUnit:用于计算两个 "日期" 间隔 (所用的)
   


---


### 3.包装类


11. 什么是包装类？
    基本数据类型所对应的对象

12.  有那些包装类

    byte       --> Byte
    short      --> Short
    char       --> Character
    int        --> Integer
    long       --> Long
    float      --> Float
    double     --->Double
    boolean    --> Boolean
    
13. JDK5以后对包装类新增了什么特性？
      自动装箱：把基本类型会自动变成其对应的包装类
      自动拆箱：把包装类型会自动变成其对应的基本类型
14. 以后如何获取包装类的？
    不需要new, 不需要调用对象，直接赋值

           Integer i = 0;

           方法名                   说明
           public static String toBinaryString(int i )      得的二进制
           public static String toOctalString(int i)             得到八进制
           public static String toHexString(int i)               得到十六进制
           public static int parseIn(String s)                   将字符串类型的整数转成int类型的整数



---


## 4.综合练习







## Day20-commonalgorithms-lambda 常见算法和lambda 

## 1.常见算法


---


## 2.Arrays


---


## 3.Lambda表达式

---


## Day21-advanced-collection(一) 集合进阶(一) 
 

## 1.集合体系结构
1. 单列结合 Collection

                                                         Collaction
                            
                                              list                                     set
                                
                                ArrayList    LinkedList    Vector               HashSet     TreeSet
                                                                        
                                                                            LinkedHashSet
2. List和Set集合的特点
   - List集合：添加元素的特点是有序的，可重复的、索引的
   - Set集合： 添加元素的特点是无序的，不重复的，无索引的
   有序时是存和取的顺序是一样的

3. Collection是单列集合的祖宗接口，它的功能是全部单列集合的都可以继承使用的

        方法名                            说明
        public boolean add(E e)           把给定的对象添加到当前集合中
        public void clear()               清空集合中的所有元素
        public boolean remove(E e)        把给定的对象在当前的集合中删除
        public boolean contaisn(Object obj) 判断集合中是否包括给定对象
        public boolean isEmpty()            判断当前集合是否为空
        public int size                     返回集合中元素的个数/集合的长度


---


## 2.Collection集合
4. Colletion的遍历方法
   - 迭代器遍历：迭代器在Java的类是Iterator,迭代器是集合通用遍历方式

   - 迭代器在遍历集合的的时候是不依赖索引的 它是通过创建指针，并移动指针来获取索引的来获取元素的
   - 迭代器的三个方法
         Collection集合获取迭代器
         方法 名                               说明
         Iterator<E> iterator()                返回迭代器对象 默认指向当前集合的0索引

         Iterator中的常用方法
         方法名                                说明
         boolean hasNext()                     判断当前位置是否有元素 有元素返回true 没元素返回false
         E next ()                             获取当前位置元素，并将迭代器对象移向下一个位置
     - 迭代器的四个细节
       - 如果当前位置没有元素，还要强行获取，会报NoSuchElementException
       - 迭代器遍历完毕，指针不会复位
       - 循环中只能用一次next方法
       - 迭代器遍历时，不能用集合的方法进行增加或删除

   - 增强for遍历
     - 增强for的底层就是一个迭代器，为了简化迭代器的代码书写的
     - 它是jdk5之后出现的，其内部原理就是一个Iterator迭代器
     - 所有的单列集合和数组才能用增强for循环进行遍历

     增强for循环格式
     
                    for(元素的数据类型 :数组或者集合 ){

                     }
      - 增强for的细节
        修改增强for的变量，不会改变集合中原本的数据
    - Lambda表达式遍历
      - 得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单，更直接遍历方式
 
              方法名                                                   说明
              default void forEach(Consumer< ? Super T > action );    结合Lambda遍历集合
5. 总结：
    - Colletion是单列集合的顶级接口 所有方法被List和Set系列结合所共享
6.  - 常见的成员方法
     add clea remove contains isEmpty size
7.  - 三种通用的遍历方式
      迭代器遍历： 在遍历的过程中需要删除元素，使用迭代器
      增强for遍 Lambda: 仅想遍历，那么使用增强for或Lambda表达式

9. 五中遍历方式总接
  - 迭代器遍历：在遍历的过程中需要操作索引 使用迭代器
  - 列表迭代器：在遍历的过程中需要添加元素 使用列表迭代器
  - 曾强for和lambda表达式遍历：仅仅想遍历，那么使用增强for和lambda表达式
  - 普通for遍历：如果遍历时想操作索引，可以使用普通for

---


## 3.list集合
8. List特有的方法
   -  Lists是Collctuon的一种，Collection的方法List都继承了
   -  List集合因为有索引，所以多了很多索引的操作方法
   
              方法名            说明、
              void add (int indx, E element)          在此集合中的指定位置插入指定元素
              E remove (int index)                    删除指定索引处的元素
              E set (int,index,E element)             修改指定索引处的元素，返回被修改的元素
              E get (int index)                       返回指定索引元素



---


## 4. 数据结构
9.  数据结构概况
    数据解构是计算机底层存储数据，组织数据的方式，
    是指数据相互之间是什么方式排序在一起的
    数据结构是为了更好方法管理和使用数据，要结合具体的业务场景进行选择
    一般情况下， 精心选择的数据结构可以带来更高的运行或存储效率
10. 数据结构(栈)
    一端开口 称为栈顶  一端封闭 称为 栈底

    数据进入栈模型的过程称为：压栈/进栈
    数据离开栈模型的过程称为：弹栈/出栈

     栈：后进先出，后进后出

    最上面的数据称为：栈顶元素
    最下面的数据称为：栈底元素

11. 数据结构(队列)
    一端开口 称为后端 一端开口 称为前端
    数据从后端进入队列模型的过程称为：入队列
    数据从前的离开队列模型的过程称为：从队列
    从队列的方式是从前端方向出去的

     队列：先进先出 ，后进后出

12. 数据结构(数组)
    数组是一种查询快，增删慢的模型
    查询速度快：查询数据通过地址值和索引定位，查询任意数据耗时相同(元素在内存中是连续存储的)
    删除效率低:要将原始数据删除，同时后面每个数据前移
    添加效率极低：添加位置后的每一个数据后移，在添加元素

13. ；数据结构(链表)
     链表里的每一个元素称为结点，每一个节点都是独立的对象，那即然是独立的对象，自身就会有地址值，表示结点在内存的位置，
     在结点里面会存储以下信息 存储具体的数据，并且存储下一个结点的地址值
     因为在链表所有的结点想一根链子一样，连接起来 

     链表中的结点是独立的对象，在内存中是不连续的，每个包括结点数据值和下一个结点的地址

     链表查询慢，无论查询哪个数据都要从头开始找
     链表增删速度比较快(相较于数组)

总结
      - 栈：后进先出，后进后出
      - 队列：先进先出，后进后出
      - 数组：在内存里是一个连续的区域，查询块，增删慢
      - 链表：元素是有离的，查询慢，首尾操作极快】

## 4.ArrayList集合
   - ArrayList集合底层原理
     - 利用空参构造创建集合，在底层创建一个默认长度为0的数组
     - 添加第一个元素时，底层会创建一个新的长度为10的数组
     - 存满时，会自动扩容1.5倍
     - 如果第一次添加多个元素，1.5倍放不下，则新创建数组的长度以实际为准

---


## 5.linkedList集合
14. 底层数据结构是双向链表，查询慢，增删快，但是操作首尾元素，速度也是极快的
15. LinkedList本身多了很多直接操作首尾元素特有API

           方法名                          说明
           public void addFirst(E e )       在该列表开头插入指定元素
           public void addLast(E e )       将指定的元素追加到此列表的末尾
           public void getFirst(E e )       返回此列表中的第一个元素
           public void getLast(E e )       返回此列表中的最后一个元素
           public void removeFirst(E e )      从此列表中删除并返回第一个元素
           ublic void removeLast(E e )      从此列表中删除并返回最后一个元素
 



## Day22-advanced-collection(二) 集合进阶(二)
# 集合进阶(二) advanced-collection(二)

## 1.泛型深入
1. 泛型的概述
   - 泛型：泛型是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查
   - 泛型的格式:<数据类型>
   - 注意：泛型只能支持引用数据类型

2. 泛型的好处
   - 统一数据类型
   - 把运行时期的问题提前到了编译时期，避免了强制类型转换可能出现的异常，因为在编译阶段类型就可以确定下来

3. java中的泛型是伪泛型

4. 泛型的细节
   - 泛型中不能写基本数据类型
   - 指定泛型具体数据类型后，传递数据时，可以传入该类类型或其子类类型
   - 如果不写泛型，类型默认时Object

5. 泛型类
   使用场景：当一个类中，某个变量数据类型不确定时，就可以定义带有泛型的类

              格式
              修饰符 class 类名<类型>{
       
              }
       
              eg
              public clss ArrayList<E>{
       
              }
              创建该对象时 E就确定类型
       
              此时泛型可以理解为变量，但是不是用来记录数据的，而是记录数据的类型，可以写成T、E、K、V等
6. 泛型方法
   方法中形参类型不确定时，可以使用类名后面定义的泛型<类型>
   方案一：使用类名后面定义的泛型        所有的方法都能使用
   方案二：在方法声明上定义自己的泛型     自有本方法能用

            格式
            修饰符<类型> 返回值类型 方法名 (类型 变量名){
       
            }
       
            eg
            public<E> void show(E e){
       
            } 

7. 泛型接口

              格式
               修饰符 interface 接口名<类型>{
               
                  }
              
                  eg
                  public interface List<E>{
              
                  }
8. 如何使用带泛型的接口
    一. 实现类给出具体类型
    二. 实现类延续泛型，创建对象时在确定
   
9.  泛型的继承和通配符
      泛型不具备继承性，但是数据具备继承性
      泛型的通配符：？

               ? extend E：表示可以传递E或者E的所有子类对象
               ? extend E：表示可以传递E或者E的所有父类对象


10. 使用场景
    - 定义类、方法、接口的时候，如果类型不确定、就可以定义泛型
    - 如果类型不确定，但是知道是那个继承体系中的，可以使用泛型的通配符





---


## 2.数据结构
11. 数据结构(树)
树里的每一个元素也叫节点，每一个节点都是一个独立的对象，但节点多个形成树的样子
      专业名词
      度：每一个节点的子节点的数量
      树高：树的总层数
      根节点：最顶层的和节点
      左子节点：左下方的节点
      右子节点：右下方的节点
      根节点的左子树：
      根节点的右子树：

12. 数据结构(二叉树)
    普通二叉树(存储数据没有特点)
    二叉树，任意节点的度<=2

13. 数据结构(二叉查找树)
      二叉查找树，有称二叉排序树
      特点：
   - 每一个节点上最多有两个子节点
   - 任意节点左子树上的值都小于当前节点
   - 任意节点的右子树上的值都大于当前节点

14. 数据结构(二叉树)添加节点规则：
   - 小的存左边
   - 大的存右边
   - 一样的不存

15. 数据结构(二叉树)单个查找规则：

16. 数据结构(二叉树)遍历方式
    - 前序遍历
      从根节点开始，然后按照当前节点，左子节点，右子节点遍历
    - 中序遍历
      从最左边的子节点开始，然后按照左子节点，当前节点，右子节点遍历
    - 后序遍历
      从最左边的子节点开始，然后按照左子节点，右子节点，当前节点遍历
    - 层序遍历
     从根节点一层一层的遍历

17. 数据结构(平衡二叉)
    规则
      任意节点的左右子树高度差不超过1


18. 旋转机制
    规则1：左旋
    规则1：
    确定支点 从添加的节点开始，不断的往父节点找不平衡的节点
      简单情况
      - 以不平衡的点作为支点
      - 把支点左旋降级，变成左子节点
      - 晋升原来的右子节点

      复杂情况

      - 以不平衡的点作为支点
      - 将根节点的右侧往左拉
      - 原先的右子节点变成新的父节点，并把多余的右子节点出让，给已经降级的节点当右子节点

    规则2：右旋
    简单情况
    确定支点 从添加的节点开始，不断的往父节点找不平衡的节点
    - 以不平衡的点作为支点
    - 把支点右旋降级，变成右子节点
    - 晋升原来的左子节点

    复杂情况

    - 以不平衡的点作为支点
    - 就是将根节点的左侧往右拉
    - 原先的左子节点变成新的父节点，并不把多余的右子节点出让，给已经降级的根节点当左子节点

20. 数据结构(平衡二叉树)需要旋转的四种情况
    - 左左
      当根节点的左子树的左子树有节点存入，导致二叉树不平衡 一次右旋

    - 左右
      当根节点左子树的右子树右节点插入，导致二叉树不平衡 先局部的左旋，在整体的右旋

    - 右右
      当根节点的右子树的右子树有节点插入，导致二叉树不平衡，一次左旋

    - 右左
      当根节点的右子树的左子树有节点插入，导致二叉树不平衡 先局部有旋在整体左旋

  



​     

​    

21. 旋转的触发时机
      当添加的一个节点之后，该树不是一颗平衡二叉树

 

22. 数据结构(平衡二叉树)小节
    - 在平衡二叉树中，如何添加元素？
       小的存左边，大的存右边，一样的不存

    - 在平衡二叉树中，如何查找单个节点？
      从根节点查找的

    - 为什么要旋转？
      为了保持平衡

    - 旋转的时机？
      破坏了这棵树的平衡，这时触发旋转，如果没有没有破坏平衡，那么就不需要旋转

    - 左左是什么意思？如何旋转？
      
    - 右右是什么意思？如何旋转？

    - 右右是什么意思？如何旋转？
      当把新节点添加到根节点左子树的左子树，破坏了平衡

    - 右左是什么意思？如何旋转？

23. 数据结构(红黑树)
    概况：
    - 红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构
    - 1972年出现，当时被称为平衡二叉B树，后来，1978年被修改为红黑树
    - 它是一种特殊的二叉查找树，红黑树的每一个节点上都有存储位表示节点的颜色
    - 每一个节点可以是红或者是黑，红黑树不是高度平衡的，它的平衡是通过红黑规则实现的

24. 数据结构(黑红规则)：
    - 每一个节点红色或者黑色
    - 根节点必须是黑色的
    - 如果一个节点没有子节点或者父节点，则该节点相应指针属性为Nil，这些Nil视为叶节点，每一个叶节点(Nil)是黑色的
    - 如果某一个节点是红色的，那么它的子节点必须是黑色的(不能出现两个红色节点相连的情况)
    - 对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包括相同数目的黑色节点

25. 数据结构(红黑树)添加元素的规则
    红黑树在添加节点的时候，添加元素默认是红色的(效率高)

![](C:\Users\kelly\Pictures\Screenshots\屏幕截图 2025-07-16 175508.png)

---


## 3.Set系列集合
26. Set集合特点
    - 无序：存取数据不一致
    - 不重复：可以去除重复
    - 无索引：没有带索引方法

27. Collection是单列集合的祖宗接口，它的功能是全部单列集合可以继续使用的。

          方法名                            说明
        public boolean add(E e)           把给定的对象添加到当前集合中
        public void clear()               清空集合中的所有元素
        public boolean remove(E e)        把给定的对象在当前的集合中删除
        public boolean contaisn(Object obj) 判断集合中是否包括给定对象
        public boolean isEmpty()            判断当前集合是否为空
        public int size                     返回集合中元素的个数/集合的长度

28. Set集合的特点
    无序，不重复，无索引
    Set集合方法基本上与Collection的API保持一致

29. Set集合实现类的特点
    HashSet:无序、不重复、无索引
    LinkedHashSet:有序、不重复、无索引
    TreeSet:可排序、不重复、无索引


---


## 4. HahSet
30. HashSet底层原理
    HashSet集合底层采取哈希表存储数据的
    哈希表是一种对于增删改查数据性能都较好的结构

31. 哈希表的组成
    JDK8之前:数组+链表
    JDK8之后:数组+链表+红黑树

31. 哈希值
    - 根据hashCode方法计算出来的int类型的整数
    - 该方法定义在Object类中所有对象都可以调用，默认使用地址只计算
    - 一般情况下，会重写HashCode方法，利用对象内部属性值计算哈希值值
    - 哈希值:对象的整数表现形式
    - int index = (数组长度 - 1 ) & 哈希值；

32. 对象的哈希值的特点
    - 如果没有重写hashCode方法，不同计算的哈希值是不同的
    - 如果已经重写了hashCode方法，不同对象只要属性值相同，计算出来的哈希值就是一样的
    - 在小部分情况下，不同属性值或是地址值计算出来的哈希值也有可能是一样(这种情况叫哈希碰撞)

33. HahSet底层怎么添加元素
   - 创建一个默认长度16，默认加载因子0.75的数组，数组名为table 
     默认加载因子0.75的数组(数组扩容机制)：也就是HashSet扩容时机，当数组存储16*0.75=12个元素时，那么此时数组扩容到原先的两倍，从16扩容到32
     - 根据元素的哈希值跟数组的长度计算出应存入的位置
     - 判断当前是否为null,如果是null直接存
     - 如果位置不是null，表示有元素，则调用equals方法比较属性值
     - 一样不存 不一样：存入数组，形成链表
       JDK8之前：新元素存入数组，老元素挂在新元素的下面
       JDK8之后：新元素挂在老元素的下面

       注意：
       JDK8以后：当链表长度超过8，而且数组长度大于等于64时，自动转为红黑树
       如果集合中存储的时自定义对象，必须重写hashCode和equals方法。如果没有重写那么在底层都是用地址值计算进行比较的

---

## 5.LinkedHashSet
34. LinkedHashSet底层原理
    - 有序、不重复、无索引
    - 这里的有序指的是保证存储和取出的元素的顺序一致
    - 原理：底层数据结构依然是哈希表，只是每一个元素有额外多个一个双链表机制记录存储顺序

35. LinkedHashSet集合的特点和原理是怎么样的
    - 有序、不重复、无索引
    - 底层基于哈希表，使用双链表记录和添加数据
  
36. 在以后如果数据去重，使用哪个
    - 默认使用HashSet
    - 如果要求去重且存取有序，才使用LinkedHashSet

---


## 6.TreeSet
37. TreeSet默认规则
    - 对于数值类型：Integer、Double 默认按照从小的大的顺序
    - 对于字符、字符串类型：按照字母在ASCLL码表数字升序，进行排序

38. TreeSet两种比较方式
    方式一：默认排序\自然排序：javabean类实现Compareable接口比较规则
    方式二：创建集合时，自定义Comparator比较器对象，指定比较规则
39. TreeSet集合的特点是怎么样的
    - 可排序、不重复、无索引
    - 底层基于红黑树实现排序，增删改查性能较好

40. TeeSet集合自定义排序规则有几种方式
    - 默认排序\自然排序：javabean类实现Compareable接口比较规则
    - 创建集合时，自定义Comparator比较器对象，指定比较规则

---


## 7.综合案例、使用场景
41. 如果想要集合元素可重复
    - 用Arraylist集合，基于数组的(用的最多)

42. 如果想要集合中的元素可重复、而且当前的增删改查操作明显多于查询
    用LinkedList集合，基于链表的

43. 如果想对集合元素去重
    - 用HashSet集合，基于哈希表(用的最多)

44. 如果想要集合中的元素去重，而且保证存取顺序
    - LinkedHashSet集合，基于哈希表和双链表，效率低于HashSet

45. 如果想对积集合元素进行排序
    用TreeSet集合，基于红黑树，后续也可以用List集合顺序排序


---


## 8.源码分析



---
@感谢B站的IT黑马   


---