# 集合进阶(二) advanced-collection(二)

## 1.泛型深入
1. 泛型的概述
   - 泛型：泛型是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查
   - 泛型的格式:<数据类型>
   - 注意：泛型只能支持引用数据类型

2. 泛型的好处
   - 统一数据类型
   - 把运行时期的问题提前到了编译时期，避免了强制类型转换可能出现的异常，因为在编译阶段类型就可以确定下来

3. java中的泛型是伪泛型

4. 泛型的细节
   - 泛型中不能写基本数据类型
   - 指定泛型具体数据类型后，传递数据时，可以传入该类类型或其子类类型
   - 如果不写泛型，类型默认时Object

5. 泛型类
   使用场景：当一个类中，某个变量数据类型不确定时，就可以定义带有泛型的类

              格式
              修饰符 class 类名<类型>{
       
              }
       
              eg
              public clss ArrayList<E>{
       
              }
              创建该对象时 E就确定类型
       
              此时泛型可以理解为变量，但是不是用来记录数据的，而是记录数据的类型，可以写成T、E、K、V等
6. 泛型方法
   方法中形参类型不确定时，可以使用类名后面定义的泛型<类型>
   方案一：使用类名后面定义的泛型        所有的方法都能使用
   方案二：在方法声明上定义自己的泛型     自有本方法能用

            格式
            修饰符<类型> 返回值类型 方法名 (类型 变量名){
       
            }
       
            eg
            public<E> void show(E e){
       
            } 

7. 泛型接口

              格式
               修饰符 interface 接口名<类型>{
               
                  }
              
                  eg
                  public interface List<E>{
              
                  }
8. 如何使用带泛型的接口
    一. 实现类给出具体类型
    二. 实现类延续泛型，创建对象时在确定
   
9.  泛型的继承和通配符
      泛型不具备继承性，但是数据具备继承性
      泛型的通配符：？

               ? extend E：表示可以传递E或者E的所有子类对象
               ? extend E：表示可以传递E或者E的所有父类对象


10. 使用场景
    - 定义类、方法、接口的时候，如果类型不确定、就可以定义泛型
    - 如果类型不确定，但是知道是那个继承体系中的，可以使用泛型的通配符





---


## 2.数据结构
11. 数据结构(树)
树里的每一个元素也叫节点，每一个节点都是一个独立的对象，但节点多个形成树的样子
      专业名词
      度：每一个节点的子节点的数量
      树高：树的总层数
      根节点：最顶层的和节点
      左子节点：左下方的节点
      右子节点：右下方的节点
      根节点的左子树：
      根节点的右子树：

12. 数据结构(二叉树)
    普通二叉树(存储数据没有特点)
    二叉树，任意节点的度<=2

13. 数据结构(二叉查找树)
      二叉查找树，有称二叉排序树
      特点：
   - 每一个节点上最多有两个子节点
   - 任意节点左子树上的值都小于当前节点
   - 任意节点的右子树上的值都大于当前节点

14. 数据结构(二叉树)添加节点规则：
   - 小的存左边
   - 大的存右边
   - 一样的不存

15. 数据结构(二叉树)单个查找规则：

16. 数据结构(二叉树)遍历方式
    - 前序遍历
      从根节点开始，然后按照当前节点，左子节点，右子节点遍历
    - 中序遍历
      从最左边的子节点开始，然后按照左子节点，当前节点，右子节点遍历
    - 后序遍历
      从最左边的子节点开始，然后按照左子节点，右子节点，当前节点遍历
    - 层序遍历
     从根节点一层一层的遍历

17. 数据结构(平衡二叉)
    规则
      任意节点的左右子树高度差不超过1


18. 旋转机制
    规则1：左旋
    规则1：
    确定支点 从添加的节点开始，不断的往父节点找不平衡的节点
      简单情况
      - 以不平衡的点作为支点
      - 把支点左旋降级，变成左子节点
      - 晋升原来的右子节点

      复杂情况

      - 以不平衡的点作为支点
      - 将根节点的右侧往左拉
      - 原先的右子节点变成新的父节点，并把多余的右子节点出让，给已经降级的节点当右子节点

    规则2：右旋
    简单情况
    确定支点 从添加的节点开始，不断的往父节点找不平衡的节点
    - 以不平衡的点作为支点
    - 把支点右旋降级，变成右子节点
    - 晋升原来的左子节点

    复杂情况

    - 以不平衡的点作为支点
    - 就是将根节点的左侧往右拉
    - 原先的左子节点变成新的父节点，并不把多余的右子节点出让，给已经降级的根节点当左子节点

20. 数据结构(平衡二叉树)需要旋转的四种情况
    - 左左
      当根节点的左子树的左子树有节点存入，导致二叉树不平衡 一次右旋

    - 左右
      当根节点左子树的右子树右节点插入，导致二叉树不平衡 先局部的左旋，在整体的右旋

    - 右右
      当根节点的右子树的右子树有节点插入，导致二叉树不平衡，一次左旋

    - 右左
      当根节点的右子树的左子树有节点插入，导致二叉树不平衡 先局部有旋在整体左旋

  



​     

​    

21. 旋转的触发时机
      当添加的一个节点之后，该树不是一颗平衡二叉树

 

22. 数据结构(平衡二叉树)小节
    - 在平衡二叉树中，如何添加元素？
       小的存左边，大的存右边，一样的不存

    - 在平衡二叉树中，如何查找单个节点？
      从根节点查找的

    - 为什么要旋转？
      为了保持平衡

    - 旋转的时机？
      破坏了这棵树的平衡，这时触发旋转，如果没有没有破坏平衡，那么就不需要旋转

    - 左左是什么意思？如何旋转？
      
    - 右右是什么意思？如何旋转？

    - 右右是什么意思？如何旋转？
      当把新节点添加到根节点左子树的左子树，破坏了平衡

    - 右左是什么意思？如何旋转？

23. 数据结构(红黑树)
    概况：
    - 红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构
    - 1972年出现，当时被称为平衡二叉B树，后来，1978年被修改为红黑树
    - 它是一种特殊的二叉查找树，红黑树的每一个节点上都有存储位表示节点的颜色
    - 每一个节点可以是红或者是黑，红黑树不是高度平衡的，它的平衡是通过红黑规则实现的

24. 数据结构(黑红规则)：
    - 每一个节点红色或者黑色
    - 根节点必须是黑色的
    - 如果一个节点没有子节点或者父节点，则该节点相应指针属性为Nil，这些Nil视为叶节点，每一个叶节点(Nil)是黑色的
    - 如果某一个节点是红色的，那么它的子节点必须是黑色的(不能出现两个红色节点相连的情况)
    - 对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包括相同数目的黑色节点

25. 数据结构(红黑树)添加元素的规则
    红黑树在添加节点的时候，添加元素默认是红色的(效率高)

![](C:\Users\kelly\Pictures\Screenshots\屏幕截图 2025-07-16 175508.png)

---


## 3.Set系列集合
26. Set集合特点
    - 无序：存取数据不一致
    - 不重复：可以去除重复
    - 无索引：没有带索引方法

27. Collection是单列集合的祖宗接口，它的功能是全部单列集合可以继续使用的。

          方法名                            说明
        public boolean add(E e)           把给定的对象添加到当前集合中
        public void clear()               清空集合中的所有元素
        public boolean remove(E e)        把给定的对象在当前的集合中删除
        public boolean contaisn(Object obj) 判断集合中是否包括给定对象
        public boolean isEmpty()            判断当前集合是否为空
        public int size                     返回集合中元素的个数/集合的长度

28. Set集合的特点
    无序，不重复，无索引
    Set集合方法基本上与Collection的API保持一致

29. Set集合实现类的特点
    HashSet:无序、不重复、无索引
    LinkedHashSet:有序、不重复、无索引
    TreeSet:可排序、不重复、无索引


---


## 4. HahSet
30. HashSet底层原理
    HashSet集合底层采取哈希表存储数据的
    哈希表是一种对于增删改查数据性能都较好的结构

31. 哈希表的组成
    JDK8之前:数组+链表
    JDK8之后:数组+链表+红黑树

31. 哈希值
    - 根据hashCode方法计算出来的int类型的整数
    - 该方法定义在Object类中所有对象都可以调用，默认使用地址只计算
    - 一般情况下，会重写HashCode方法，利用对象内部属性值计算哈希值值
    - 哈希值:对象的整数表现形式
    - int index = (数组长度 - 1 ) & 哈希值；

32. 对象的哈希值的特点
    - 如果没有重写hashCode方法，不同计算的哈希值是不同的
    - 如果已经重写了hashCode方法，不同对象只要属性值相同，计算出来的哈希值就是一样的
    - 在小部分情况下，不同属性值或是地址值计算出来的哈希值也有可能是一样(这种情况叫哈希碰撞)

33. HahSet底层怎么添加元素
   - 创建一个默认长度16，默认加载因子0.75的数组，数组名为table 
     默认加载因子0.75的数组(数组扩容机制)：也就是HashSet扩容时机，当数组存储16*0.75=12个元素时，那么此时数组扩容到原先的两倍，从16扩容到32
     - 根据元素的哈希值跟数组的长度计算出应存入的位置
     - 判断当前是否为null,如果是null直接存
     - 如果位置不是null，表示有元素，则调用equals方法比较属性值
     - 一样不存 不一样：存入数组，形成链表
       JDK8之前：新元素存入数组，老元素挂在新元素的下面
       JDK8之后：新元素挂在老元素的下面

       注意：
       JDK8以后：当链表长度超过8，而且数组长度大于等于64时，自动转为红黑树
       如果集合中存储的时自定义对象，必须重写hashCode和equals方法。如果没有重写那么在底层都是用地址值计算进行比较的

---

## 5.LinkedHashSet
34. LinkedHashSet底层原理
    - 有序、不重复、无索引
    - 这里的有序指的是保证存储和取出的元素的顺序一致
    - 原理：底层数据结构依然是哈希表，只是每一个元素有额外多个一个双链表机制记录存储顺序

35. LinkedHashSet集合的特点和原理是怎么样的
    - 有序、不重复、无索引
    - 底层基于哈希表，使用双链表记录和添加数据
  
36. 在以后如果数据去重，使用哪个
    - 默认使用HashSet
    - 如果要求去重且存取有序，才使用LinkedHashSet

---


## 6.TreeSet
37. TreeSet默认规则
    - 对于数值类型：Integer、Double 默认按照从小的大的顺序
    - 对于字符、字符串类型：按照字母在ASCLL码表数字升序，进行排序

38. TreeSet两种比较方式
    方式一：默认排序\自然排序：javabean类实现Compareable接口比较规则
    方式二：创建集合时，自定义Comparator比较器对象，指定比较规则
39. TreeSet集合的特点是怎么样的
    - 可排序、不重复、无索引
    - 底层基于红黑树实现排序，增删改查性能较好

40. TeeSet集合自定义排序规则有几种方式
    - 默认排序\自然排序：javabean类实现Compareable接口比较规则
    - 创建集合时，自定义Comparator比较器对象，指定比较规则

---


## 7.综合案例、使用场景
41. 如果想要集合元素可重复
    - 用Arraylist集合，基于数组的(用的最多)

42. 如果想要集合中的元素可重复、而且当前的增删改查操作明显多于查询
    用LinkedList集合，基于链表的

43. 如果想对集合元素去重
    - 用HashSet集合，基于哈希表(用的最多)

44. 如果想要集合中的元素去重，而且保证存取顺序
    - LinkedHashSet集合，基于哈希表和双链表，效率低于HashSet

45. 如果想对积集合元素进行排序
    用TreeSet集合，基于红黑树，后续也可以用List集合顺序排序


---


## 8.源码分析

``
